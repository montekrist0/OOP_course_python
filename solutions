

# --------------------------------------------------------------------------------------------------------
# ----------Вариант мой
# class Circle:
#     def __init__(self, x, y, radius) -> None:
#         self.__x = x
#         self.__y = y
#         self.__radius = radius

#     @property
#     def x(self):
#         return self.__x

#     @x.setter
#     def x(self, x):
#         self.__x = x

#     @property
#     def y(self):
#         return self.__y

#     @y.setter
#     def y(self, y):
#         self.__y = y

#     @property
#     def radius(self):
#         return self.__radius

#     @radius.setter
#     def radius(self, radius):
#         self.__radius = radius

#     def __setattr__(self, key, value):
#         if key in ('_Circle__x', '_Circle__y', '_Circle__radius'):
#             if not isinstance(value, (int, float)):
#                 raise TypeError("Неверный тип присваиваемых данных.")
#             else:
#                 if key == '_Circle__radius' and value < 0:
#                     return
#         object.__setattr__(self, key, value)

#     def __getattr__(self, __name: str):
#         return False


# circle = Circle(10.5, 7, 22)
# # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
# circle.radius = -10
# # circle.x = "wfwr"
# # circle.x = "wrf
# print(circle.__dict__)
# x, y, radius = circle.x, circle.y, circle.radius
# print(f"x = {x}, y = {y}, radius = {radius}")
# # res = circle.name # False, т.к. атрибут name не существует
# print(circle.name)
# -----------------Вариант сына маминой подруги
class Value:
    def __set_name__(self, owner, name):
        self.name = f'__{name}'

    def __get__(self, instance, owner):
        return property() if instance is None else getattr(instance, self.name)

    def __set__(self, instance, value):
        if self.validate(value):
            setattr(instance, self.name, value)

    def validate(self, value) -> bool:
        raise NotImplemented


class Number(Value):
    def validate(self, value) -> bool:
        if not isinstance(value, (int, float)):
            raise TypeError("Неверный тип присваиваемых данных.")
        return True


class PositiveNumber(Number):
    def validate(self, value) -> bool:
        return super(PositiveNumber, self).validate(value) and value > 0


class Circle:
    x = Number()
    y = Number()
    radius = PositiveNumber()

    def __init__(self, x, y, radius):
        self.x, self.y, self.radius = x, y, radius

    def __getattr__(self, item):
        return False


circle = Circle(10.5, 7, 22)
# прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
circle.radius = -10
# circle.x = "wfwr"
# circle.x = "wrf
print(circle.__dict__)
x, y, radius = circle.x, circle.y, circle.radius
print(f"x = {x}, y = {y}, radius = {radius}")
# res = circle.name # False, т.к. атрибут name не существует
print(circle.name)
# --------------------------------------------------------------------------------------------------------

# class AppVK:
#     def __init__(self) -> None:
#         self.name = "ВКонтакте"


# class AppYouTube:
#     def __init__(self, memory_max: int) -> None:
#         self.name = "YouTube"
#         self.memory_max = memory_max


# class AppPhone:
#     def __init__(self, phone_list: dict) -> None:
#         self.name = "Phone"
#         self.phone_list = phone_list


# class SmartPhone:
#     def __init__(self, model) -> None:
#         self.model = model
#         self.apps = []
#         self.objects = {}

#     def add_app(self, app):
#         t = type(app)
#         if type(app) in self.objects:
#             return
#         self.apps.append(app)
#         self.objects.setdefault(type(app))

#     def remove_app(self, app):
#         if type(app) in self.objects:
#             self.apps.remove(app)
#             del self.objects[type(app)]


# sm = SmartPhone("Honor 1.0")
# sm.add_app(AppVK())
# sm.add_app(AppVK())  # второй раз добавляться не должно
# sm.add_app(AppYouTube(2048))
# for a in sm.apps:
#     print(a.name)

# --------------------------------------------------------------------------------------------------------

# class Telecast:
#     def __init__(self, id, name, duration) -> None:
#         self.__id = id
#         self.__name = name
#         self.__duration = duration

#     @property
#     def uid(self):
#         return self.__id

#     @uid.setter
#     def uid(self, id):
#         self.__id = id

#     @property
#     def name(self):
#         return self.__name

#     @name.setter
#     def name(self, name):
#         self.__name = name

#     @property
#     def duration(self):
#         return self.__duration

#     @duration.setter
#     def duration(self, duration):
#         self.__duration = duration


# class TVProgram:
#     def __init__(self, name) -> None:
#         self.name = name
#         self.items = []
#         self.telecast_indexes = {}

#     def add_telecast(self, tl: Telecast):
#         if self.telecast_indexes.get(tl.uid):
#             return
#         self.items.append(tl)
#         self.telecast_indexes.setdefault(tl.uid, self.items[-1])

#     def remove_telecast(self, indx: int):
#         tl = self.telecast_indexes.get(indx)
#         if tl:
#             self.items.remove(tl)
#             del self.telecast_indexes[indx]


# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# for t in pr.items:
#     print(f"{t.name}: {t.duration}")
# print('------------------------------------')
# pr.remove_telecast(2)
# pr.remove_telecast(2)
# pr.add_telecast(Telecast(4, "4 телеканал", 2000))
# pr.add_telecast(Telecast(5, "5 телеканал", 20))
# for t in pr.items:
#     print(f"{t.name}: {t.duration}")
# --------------------------------------------------------------------------------------------------------

# class Thing:
#     def __init__(self, name, weight) -> None:
#         self.name = name
#         self.weight = weight


# class Bag:
#     def __init__(self, max_weight) -> None:
#         self.max_weight = max_weight
#         self.__things = []
#         self.total_weight = 0

#     @property
#     def things(self):
#         return self.__things

#     def add_thing(self, thing: Thing):
#         if self.total_weight + thing.weight <= 1000:
#             self.things.append(thing)
#             self.total_weight += thing.weight

#     def remove_thing(self, indx):
#         thing = self.things.pop(indx)
#         if thing:
#             self.total_weight -= thing.weight

#     def get_total_weight(self):
#         return self.total_weight


# bag = Bag(1000)
# bag.add_thing(Thing("Книга по Python", 100))
# bag.add_thing(Thing("Котелок", 500))
# bag.add_thing(Thing("Спички", 20))
# bag.add_thing(Thing("Бумага", 100))
# w = bag.get_total_weight()
# print(w)
# for t in bag.things:
#     print(f"{t.name}: {t.weight}")

# --------------------------------------------------------------------------------------------------------

# class ProductValue:
#     def __init__(self, max_value) -> None:
#         self.max_value = max_value

#     def __set_name__(self, owner, name):
#         self.name = '_' + name

#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)

#     def __set__(self, instance, value):
#         if type(value) == int:
#             if 0 <= value <= self.max_value:
#                 setattr(instance, self.name, value)


# class StringValue:
#     def __init__(self, min_length, max_length) -> None:
#         self.min_length = min_length
#         self.max_length = max_length

#     def __set_name__(self, owner, name):
#         self.name = '_' + name

#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)

#     def __set__(self, instance, value):
#         if type(value) == str:
#             if self.min_length <= len(value) <= self.max_length:
#                 setattr(instance, self.name, value)


# class Product:
#     name = StringValue(2, 50)
#     price = ProductValue(10000)

#     def __init__(self, name, price) -> None:
#         self.name = name
#         self.price = price


# class SuperShop:
#     def __init__(self, name) -> None:
#         self.name = name
#         self.goods = []

#     def add_product(self, product: Product):
#         self.goods.append(product)

#     def remove_product(self, product: Product):
#         self.goods.remove(product)


# shop = SuperShop("У Балакирева")
# shop.add_product(Product("Курс по Python", 0))
# shop.add_product(Product("Курс по Python ООП", 2000))
# for p in shop.goods:
#     print(f"{p.name}: {p.price}")

# --------------------------------------------------------------------------------------------------------

# class ValidateString:
#     def __init__(self, min_length, max_length) -> None:
#         self.min_length = min_length
#         self.max_length = max_length

#     def validate(self, string):
#         if type(string) == str:
#             if self.min_length <= len(string) <= self.max_length:
#                 return True
#         return False


# class StringValue:
#     def __init__(self, validator: ValidateString) -> None:
#         self.validator = validator

#     def __set_name__(self, owner, name):
#         self.name = '_' + name

#     def __get__(self, instance, owner):
#         res = getattr(instance, self.name)
#         return getattr(instance, self.name)

#     def __set__(self, instance, value):
#         if self.validator.validate(value):
#             setattr(instance, self.name, value)


# class RegisterForm:
#     login = StringValue(validator=ValidateString(3, 100))
#     password = StringValue(validator=ValidateString(3, 100))
#     email = StringValue(validator=ValidateString(3, 100))

#     def __init__(self, login, password, email) -> None:
#         self.login = login
#         self.password = password
#         self.email = email

#     def get_fields(self):
#         return [self.login, self.password, self.email]

#     def show(self):
#         print(
#             f"<form>\nЛогин: {self.login}\nПароль: {self.password}\nEmail: {self.email}\n</form>")


# form = RegisterForm("bog", "qwerty123", "kuku@mail.ru")
# form.show()
# form.pr()
# --------------------------------------------------------------------------------------------------------

# class FloatValue:
#     def __set_name__(self, owner, name):
#         self.name = "_" + name

#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)

#     def __set__(self, instance, value):
#         self.check_float(value)
#         setattr(instance, self.name, value)
#         instance.__dict__[self.name] = value

#     @staticmethod
#     def check_float(value):
#         if type(value) != float:
#             raise TypeError(
#                 "Присваивать можно только вещественный тип данных.")

# class Cell:
#     value = FloatValue()

#     def __init__(self, value=0.0) -> None:
#         self.value = value

# class TableSheet:
#     def __init__(self, N, M) -> None:
#         self.cells = [[Cell() for _ in range(M)] for _ in range(N)]

# table = TableSheet(5, 3)
# init_value = 1.0
# for row in table.cells:
#     for cell in row:
#         cell.value = init_value
#         init_value += 1

# result = [[cell.value for cell in row] for row in table.cells]
# print(*result, sep='\n')

# --------------------------------------------------------------------------------------------------------

# from re import match

# class PhoneNumber:
#     def __init__(self, number, fio) -> None:
#         if self.check_number(number) and isinstance(fio, str):
#             self.number = number
#             self.fio = fio
#         else:
#             raise Exception(
#                 f"некорректные входные данные для создания объекта: {number}\t, {fio}")

#     @staticmethod
#     def check_number(number):
#         return match(r"^\d{11}$", str(number))

# class PhoneBook:
#     def __init__(self) -> None:
#         self.__phones = []

#     @property
#     def phones(self):
#         return self.__phones

#     def add_phone(self, phone):
#         self.phones.append(phone)

#     def remove_phone(self, indx):
#         phones_number = len(self.phones)
#         if -phones_number <= indx <= phones_number-1:
#             self.phones.pop(indx)
#         else:
#             raise Exception(f"You can't get phone number by index={indx}")

#     def get_phone_list(self):
#         return self.phones

# p = PhoneBook()
# p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
# p.add_phone(PhoneNumber(21345678901, "Панда"))
# phones = p.get_phone_list()
# p.remove_phone(0)
# print(phones)
# --------------------------------------------------------------------------------------------------------

# from math import sqrt

# class LineTo:
#     def __init__(self, x=0, y=0) -> None:
#         self.x = x
#         self.y = y

# class PathLines:
#     def __init__(self, *args: LineTo) -> None:
#         self.start_point = LineTo()
#         self.last_point = self.start_point
#         self.lines = []
#         self.length = 0
#         for point in args:
#             self.length += self.calc_length(self.last_point, point)
#             self.last_point = point
#             self.lines.append(point)

#     def get_path(self) -> list:
#         return self.lines

#     def get_length(self) -> int:
#         return self.length

#     def add_line(self, line: LineTo) -> None:
#         self.length += self.calc_length(self.last_point, line)
#         self.last_point = line
#         self.lines.append(line)

#     @staticmethod
#     def calc_length(p0: LineTo, p1: LineTo) -> int:
#         return sqrt((p1.x-p0.x)**2 + (p1.y-p0.y)**2)

# p = PathLines(LineTo(1, 2))
# print(p.get_length())  # 2.23606797749979
# p.add_line(LineTo(10, 20))
# p.add_line(LineTo(5, 17))
# print(p.get_length())  # 28.191631669843197
# m = p.get_path()
# print(all(isinstance(i, LineTo) for i in m) and len(m) == 3)  # True

# h = PathLines(LineTo(4, 8), LineTo(-10, 30), LineTo(14, 2))
# print(h.get_length())  # 71.8992593599813

# k = PathLines()
# print(k.get_length())  # 0
# print(k.get_path())  # []
# p = PathLines(LineTo(10, 20), LineTo(10, 30))
# p.add_line(LineTo(20, -10))
# dist = p.get_length()
# print(dist)

# --------------------------------------------------------------------------------------------------------

# class TreeObj:
#     def __init__(self, indx, value=None) -> None:
#         self.indx = indx
#         self.value = value
#         self.__left = None
#         self.__right = None

#     @property
#     def left(self):
#         return self.__left

#     @left.setter
#     def left(self, left):
#         self.__left = left

#     @property
#     def right(self):
#         return self.__right

#     @right.setter
#     def right(self, right):
#         self.__right = right

# class DecisionTree:
#     __root = None

#     @classmethod
#     def predict(cls, root: TreeObj, x: list):
#         next_node = root
#         while next_node.left or next_node.right:
#             if x[next_node.indx]:
#                 next_node = next_node.left
#             else:
#                 next_node = next_node.right
#         return next_node.value

#     @classmethod
#     def add_obj(cls, obj: TreeObj, node: TreeObj = None, left=True):
#         if cls.__root == None and node == None and isinstance(obj, TreeObj):
#             cls.__root = obj
#             return obj
#         elif node != None:
#             if left:
#                 node.left = obj
#             else:
#                 node.right = obj
#             return obj

# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

# x = [1, 1, 0]
# res = DecisionTree.predict(root, x)  # будет программистом
# --------------------------------------------------------------------------------------------------------

# class RadiusVector2D:
#     MIN_COORD = -100
#     MAX_COORD = 1024

#     def __init__(self, x=0, y=0) -> None:
#         if self.check_coord(x) and self.check_coord(y):
#             self.__x = x
#             self.__y = y
#         else:
#             self.__x = 0
#             self.__y = 0

#     @classmethod
#     def check_coord(cls, c):
#         if type(c) in (int, float):
#             if cls.MIN_COORD <= c <= cls.MAX_COORD:
#                 return True
#         return False

#     @property
#     def x(self):
#         return self.__x

#     @x.setter
#     def x(self, x):
#         if self.check_coord(x):
#             self.__x = x

#     @property
#     def y(self):
#         return self.__y

#     @y.setter
#     def y(self, y):
#         if self.check_coord(y):
#             self.__y = y

#     @staticmethod
#     def norm2(vector):
#         return vector.x**2 + vector.y**2

# --------------------------------------------------------------------------------------------------------

# def isPalindrome(x):
#     """
#     :type x: int
#     :rtype: bool
#     """
#     if x < 0:
#         return False
#     elif 0 <= x <= 9:
#         return True
#     else:
#         s = str(x)
#         mid = int(len(s)/2)
#         return s[:mid] == s[-1:-mid-1:-1]

# print(isPalindrome(121))  # true
# print(isPalindrome(1221))  # true
# print(isPalindrome(12321))  # true
# print(isPalindrome(2121))  # false
# print(isPalindrome(1))  # true
# print(isPalindrome(-2))  # false

# --------------------------------------------------------------------------------------------------------

# class StackObj:
#     def __init__(self, data) -> None:
#         self.__next = None
#         self.__data = data

#     @property
#     def next(self):
#         return self.__next

#     @next.setter
#     def next(self, next):
#         if type(next) == StackObj or next == None:
#             self.__next = next

#     @property
#     def data(self):
#         return self.__data

#     @data.setter
#     def data(self, data):
#         self.__data = data

# class Stack:
#     def __init__(self) -> None:
#         self.top: StackObj = None

#     def push(self, obj: StackObj):
#         if self.top == None:
#             self.top = obj
#             return
#         last = self.top
#         while last.next != None:
#             last = last.next
#         last.next = obj

#     def pop(self):
#         if self.top == None:
#             return
#         elif self.top.next == None:
#             copy = self.top
#             self.top = None
#             return copy
#         else:
#             last = self.top
#             while last.next.next != None:
#                 last = last.next
#             copy = last.next
#             last.next = None
#             return copy

#     def get_data(self):
#         result = []
#         last = self.top
#         while last:
#             result.append(last.data)
#             last = last.next
#         return result

# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# st.push(StackObj("obj3"))
# removed_obj = st.pop()
# removed_obj = st.pop()
# removed_obj = st.pop()
# removed_obj = st.pop()
# res = st.get_data()    # ['obj1', 'obj2']
# print(res)
# --------------------------------------------------------------------------------------------------------

# class WindowDlg:
#     def __init__(self, title, width, height) -> None:
#         self.__title = title
#         self.__width = width
#         self.__height = height

#     def show(self):
#         print(f"{self.__title}: {self.__width}, {self.__height}")

#     @property
#     def width(self):
#         return self.__width

#     @width.setter
#     def width(self, width):
#         if type(width) == int and 0 <= width <= 10000:
#             self.__width = width
#             self.show()

#     @property
#     def height(self):
#         return self.__height

#     @height.setter
#     def height(self, height):
#         if type(height) == int and 0 <= height <= 10000:
#             self.__height = height
#             self.show()

# w = WindowDlg("Окно", 100, 50)
# w.height = 200
# w.width = 300
# console.log('');

# --------------------------------------------------------------------------------------------------------

# from random import randint, choice, choices
# from string import ascii_letters, digits
# from itertools import groupby

# class EmailValidator:
#     __symbols = ascii_letters + digits + '.' + '_'
#     __min_email_name_len = 1
#     __max_email_name_len = 100
#     __max_domain_name_len = 50

#     def __new__(cls, *args, **kwargs):
#         return None

#     @classmethod
#     def get_random_email(cls):
#         domain_name = "@gmail.com"
#         raw_list = choices(cls.__symbols, k=randint(
#             cls.__min_email_name_len, cls.__max_email_name_len))
#         email_name = ''.join(el for el, group in groupby(
#             raw_list) if len(tuple(group)) != 2 and el != '.')
#         return email_name + domain_name

#     @classmethod
#     def check_email(cls, email):
#         if cls.__is_email_str(email):
#             pass
#         return False

#     @staticmethod
#     def __is_email_str(email):
#         return isinstance(email, str)

# # print(ascii_letters, digits)
# # res = EmailValidator.get_random_email()
# # print(type(res))
# # print(res)
# # print(len(res))

# word = "helllll.l..o"
# res = ''.join(letter for letter, group in groupby(
#     word) if len(tuple(group)) != 2)
# for letter, group in groupby(word):
#     print(tuple(group))
# # print(res)
# --------------------------------------------------------------------------------------------------------

# class ObjList:
#     def __init__(self, data) -> None:
#         self.__next = None
#         self.__prev = None
#         self.__data = data

#     def set_next(self, obj):
#         self.__next = obj

#     def set_prev(self, obj):
#         self.__prev = obj

#     def get_next(self):
#         return self.__next

#     def get_prev(self):
#         return self.__prev

#     def set_data(self, data):
#         self.__data = data

#     def get_data(self):
#         return self.__data

# class LinkedList:
#     def __init__(self) -> None:
#         self.head: ObjList = None
#         self.tail: ObjList = None

#     def add_obj(self, obj: ObjList):
#         if self.head is None:
#             self.tail = self.head = obj
#         else:
#             self.tail.set_next(obj)
#             obj.set_prev(self.tail)
#             self.tail = obj

#     def remove_obj(self):
#         if self.tail is None:
#             return
#         if self.tail.get_prev() is None:
#             self.tail = self.head = None
#             return
#         self.tail = self.tail.get_prev()
#         self.tail.set_next(None)

#     def get_data(self):
#         result = []
#         obj = self.head
#         while obj:
#             result.append(obj.get_data())
#             obj = obj.get_next()
#         return result

# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# print(res)
# lst.remove_obj()
# res = lst.get_data()
# print(res)
# lst.remove_obj()
# res = lst.get_data()
# print(res)
# lst.remove_obj()
# res = lst.get_data()
# print(res)
# lst.remove_obj()

# --------------------------------------------------------------------------------------------------------

# class Point:
#     def __init__(self, x, y) -> None:
#         self.__x = x
#         self.__y = y

#     def get_coords(self):
#         return self.__x, self.__y

# class Rectangle:
#     def __init__(self, *args) -> None:
#         if len(args) == 4:
#             self.__x1, self.__y1, self.__x2, self.__y2 = args
#             self.__sp = Point(self.__x1, self.__y1)
#             self.__ep = Point(self.__x2, self.__y2)
#         elif len(args) == 2:
#             self.__sp, self.__ep = args
#         else:
#             raise TypeError(
#                 "Передано неверное количество параметров при создании объекта Rectangle. Требуется 2 или 4")

#     def get_coords(self):
#         return self.__sp, self.__ep

#     def set_coords(self, sp, ep):
#         self.__sp = sp
#         self.__ep = ep

#     def draw(self):
#         return f"Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}"

# rect = Rectangle(0, 0, 20, 34)
# r1 = Rectangle(1, 1, 4, 4)
# p1 = Point(10, 10)
# p2 = Point(55, 55)
# r2 = Rectangle(p1, p2)
# print(r1.draw())
# print(r2.draw())
# --------------------------------------------------------------------------------------------------------
# class Line:
#     def __init__(self, *args):
#         self.__x1, self.__y1, self.__x2, self.__y2 = args

#     def set_coords(self, x1, y1, x2, y2):
#         self.__x1 = x1
#         self.__y1 = y1
#         self.__x2 = x2
#         self.__y2 = y2

#     def get_coords(self):
#         return self.__x1, self.__y1, self.__x2, self.__y2

#     def draw(self):
#         print(*self.get_coords())

# l = Line(1, 2, 3, 4)
# l.draw()
# --------------------------------------------------------------------------------------------------------
# class Book:
#     def __init__(self, author, title, price) -> None:
#         self.__author = author
#         self.__title = title
#         self.__price = price

#     def set_title(self, title):
#         self.__title = title

#     def set_author(self, author):
#         self.__author = author

#     def set_price(self, price):
#         self.__price = price

#     def get_title(self):
#         return self.__title

#     def get_author(self):
#         return self.__author

#     def get_price(self):
#         return self.__price

# --------------------------------------------------------------------------------------------------------

# class Money:
#     def __init__(self, money) -> None:
#         self.__money = money

#     @classmethod
#     def __check_money(cls, money) -> bool:
#         return type(money) == int and money >= 0

#     def set_money(self, money):
#         if self.__check_money(money):
#             self.__money = money

#     def get_money(self):
#         return self.__money

#     def add_money(self, money):
#         self.__money += money.get_money()

# --------------------------------------------------------------------------------------------------------

# class Clock:
#     def __init__(self, time=0) -> None:
#         self.__time = time

#     @classmethod
#     def __check_time(cls, tm):
#         return 0 <= tm <= 100000

#     def set_time(self, tm):
#         if self.__check_time(tm):
#             self.__time = tm

#     def get_time(self):
#         return self.__time

# clock = Clock(4530)
# print(clock.get_time())
# --------------------------------------------------------------------------------------------------------

# from random import randrange

# class Data:
#     def __init__(self, data, ip) -> None:
#         self.data = data
#         self.ip = ip

# class Server:
#     __MAX_NUMBER_OF_SERVERS = 10
#     __ip_adresses = list(range(1, __MAX_NUMBER_OF_SERVERS))

#     def __init__(self) -> None:
#         self.buffer = []
#         self.ip = Server.__ip_adresses.pop(
#             randrange(len(Server.__ip_adresses)))
#         self.router: Router = None

#     def __del__(self):
#         Server.__ip_adresses.append(self.ip)

#     def send_data(self, data: Data):
#         if self.router:
#             self.router.get_from_server(data)

#     def get_data(self):
#         return [self.buffer.pop() for _ in range(len(self.buffer))]

#     def get_ip(self):
#         return self.ip

#     def link_to_router(self, router):
#         self.router = router

#     def unlink_router(self):
#         self.router = None

#     def get_data_from_router(self, data):
#         self.buffer.append(data)

# class Router:
#     __instance = None

#     def __new__(cls, *args, **kwargs):
#         if cls.__instance is None:
#             cls.__instance = super().__new__(cls)
#         return cls.__instance

#     def __del__(self):
#         Router.__instance = None

#     def __init__(self) -> None:
#         self.buffer = []
#         self.servers = {}

#     def link(self, server: Server):
#         self.servers.setdefault(server.get_ip(), server)
#         server.link_to_router(self)

#     def unlink(self, server: Server):
#         s_ip = server.get_ip()
#         if s_ip in self.servers:
#             del self.servers[s_ip]
#             server.unlink_router()

#     def send_data(self):
#         while len(self.buffer):
#             data = self.buffer.pop()
#             if data.ip in self.servers:
#                 server = self.servers[data.ip]
#                 server.get_data_from_router(data)

#     def get_from_server(self, data):
#         self.buffer.append(data)

# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# print(msg_lst_from)
# print(msg_lst_to)
# --------------------------------------------------------------------------------------------------------

# class Message:
#     __n = 0

#     def __init__(self, text) -> None:
#         self.text = text
#         self.fl_like = False
#         self.msg_number = Message.__n
#         Message.__n += 1

#     def get_msg_number(self):
#         return self.msg_number

#     def set_like(self):
#         self.fl_like = not self.fl_like

# class Viber:
#     messages = {}

#     @classmethod
#     def add_message(cls, msg: Message):
#         cls.messages.setdefault(msg.get_msg_number(), msg)

#     @classmethod
#     def remove_message(cls, msg: Message):
#         msg_num = msg.get_msg_number()
#         if msg_num in cls.messages:
#             del cls.messages[msg_num]

#     @staticmethod
#     def set_like(msg: Message):
#         msg.set_like()

#     @classmethod
#     def show_last_message(cls, n=10):
#         amount_of_messages = len(cls.messages)
#         messages = list(cls.messages.values())
#         if n <= 0:
#             return
#         if n >= amount_of_messages:
#             return [(f"Message text: {msg.text}", f"Liked: {msg.fl_like}") for msg in messages]
#         return [(f"Message text: {msg.text}", f"Liked: {msg.fl_like}") for msg in messages[amount_of_messages-n:]]

#     @classmethod
#     def total_messages(cls):
#         return len(cls.messages)

# msg = Message("Всем привет!")
# Viber.add_message(msg)
# print(Viber.show_last_message())
# Viber.add_message(Message("Это курс по Python ООП."))
# print(Viber.show_last_message(1))
# Viber.add_message(Message("Что вы о нем думаете?"))
# print(Viber.show_last_message())
# Viber.set_like(msg)
# print(Viber.show_last_message())
# Viber.remove_message(msg)
# print(Viber.show_last_message())

# --------------------------------------------------------------------------------------------------------

# class Application:
#     def __init__(self, name) -> None:
#         self.name = name
#         self.blocked = False

# class AppStore:
#     def __init__(self) -> None:
#         self.apps = {}

#     def add_application(self, app: Application):
#         self.apps[app.name] = app

#     def remove_application(self, app: Application):
#         if app.name in self.apps:
#             del self.apps[app.name]

#     def block_application(self, app: Application):
#         if app.name in self.apps:
#             self.apps[app.name].blocked = True

#     def total_apps(self):
#         return len(self.apps)

# store = AppStore()
# app_youtube = Application("Youtube")
# print(store.apps)
# store.add_application(app_youtube)
# print(store.apps)
# store.remove_application(app_youtube)
# print(store.apps)

# --------------------------------------------------------------------------------------------------------

# class Video:
#     def create(self, name):
#         self.name = name

#     def play(self):
#         print(f"воспроизведение видео {self.name}")

# class YouTube:
#     videos = []

#     @classmethod
#     def add_video(cls, video):
#         cls.videos.append(video)

#     @classmethod
#     def play(cls, video_indx):
#         cls.videos[video_indx].play()

# v1 = Video()
# v1.create('Python')
# v2 = Video()
# v2.create('Python ООП')
# YouTube.add_video(v1)
# YouTube.add_video(v2)
# YouTube.play(0)
# YouTube.play(1)
# --------------------------------------------------------------------------------------------------------

# from string import ascii_lowercase, digits
# import re

# class CardCheck:
#     CHARS_FOR_NAME = ascii_lowercase.upper() + digits
#     number_pattern = r"\d{4}-\d{4}-\d{4}-\d{4}"
#     name_pattern = r"[A-Z]+\s?[A-Z]+$"

#     def __init__(self) -> None:
#         pass

#     @classmethod
#     def check_card_number(cls, number):
#         if re.fullmatch(cls.number_pattern, number):
#             return True
#         return False

#     @classmethod
#     def check_name(cls, name):
#         if re.fullmatch(cls.name_pattern, name):
#             return True
#         return False

# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# print(is_number, is_name)

# --------------------------------------------------------------------------------------------------------

# from string import ascii_lowercase, digits

# # здесь объявляйте классы TextInput и PasswordInput

# import re

# class TextInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits

#     @staticmethod
#     def check_valid(text):
#         return bool(re.search('[а-яА-Яa-zA-Z\s\d]', text))

#     @classmethod
#     def check_name(cls, name):
#         is_valid = (3 <= len(name) <= 50) and all(
#             [cls.check_valid(el) for el in name])
#         if is_valid:
#             return True
#         else:
#             raise ValueError("некорректное поле name")

#     def __init__(self, name, size=10) -> None:
#         if self.check_name(name):
#             self.name = name
#             self.size = size

#     def get_html(self):
#         return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"

# class PasswordInput:
#     CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
#     CHARS_CORRECT = CHARS + CHARS.upper() + digits

#     @staticmethod
#     def check_valid(text):
#         return bool(re.search('[а-яА-Яa-zA-Z\s\d]', text))

#     @classmethod
#     def check_name(cls, name):
#         is_valid = (3 <= len(name) <= 50) and all(
#             [cls.check_valid(el) for el in name])
#         if is_valid:
#             return True
#         else:
#             raise ValueError("некорректное поле name")

#     def __init__(self, name, size=10) -> None:
#         if self.check_name(name):
#             self.name = name
#             self.size = size

#     def get_html(self):
#         return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw

#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])

# # эти строчки не менять
# login = FormLogin(TextInput("Login123"), PasswordInput("Пароль"))
# html = login.render_template()
# print(html)

# --------------------------------------------------------------------------------------------------------
# import sys

# class ListObject():
#     def __init__(self, data: str) -> None:
#         self.next_obj = None
#         self.data = data

#     def link(self, obj):
#         self.next_obj = obj

# def get_next_elements(lst_obj: ListObject, index: int):
#     if index >= len(lst_in) - 1:
#         return lst_obj
#     else:
#         lst_obj.next_obj = ListObject(lst_in[index+1])
#         get_next_elements(lst_obj.next_obj, index + 1)

# lst_in = list(map(str.strip, sys.stdin.readlines()))

# head_obj = ListObject(lst_in[0])
# get_next_elements(head_obj, 0)
# cur_obj = head_obj
# print("--------------------------output--------------------------")

# while True:
#     if cur_obj.next_obj is not None:
#         print(cur_obj.data)
#         cur_obj = cur_obj.next_obj
#     else:
#         print(cur_obj.data)
#         break

# --------------------------------------------------------------------------------------------------------
# class Cart:
#     def __init__(self) -> None:
#         self.goods = []

#     def add(self, gd):
#         self.goods.append(gd)

#     def remove(self, indx):
#         self.goods.pop(indx)

#     def get_list(self):
#         return [
#             f"{gd.name}: {gd.price}" for gd in self.goods
#         ]

# class Table:
#     def __init__(self, name, price) -> None:
#         self.name = name
#         self.price = price

# class TV:
#     def __init__(self, name, price) -> None:
#         self.name = name
#         self.price = price

# class Notebook:
#     def __init__(self, name, price) -> None:
#         self.name = name
#         self.price = price

# class Cup:
#     def __init__(self, name, price) -> None:
#         self.name = name
#         self.price = price

# tv1 = TV("samsung", 1111)
# tv2 = TV("LG", 1234)
# table = Table("ikea", 2345)
# n1 = Notebook("msi", 5433)
# n2 = Notebook("apple", 542)
# c = Cup("keepcup", 43)

# cart = Cart()
# cart.add(tv1)
# cart.add(tv2)
# cart.add(n1)
# cart.add(n2)
# cart.add(table)
# cart.add(c)

# print(cart.get_list())

# --------------------------------------------------------------------------------------------------------
# import sys

# # программу не менять, только добавить два метода
# # считывание списка строк из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')

#     # здесь добавлять методы\
#     def select(self, a, b):
#         if b < len(DataBase.lst_data):
#             return DataBase.lst_data[a:b+1]
#         else:
#             return DataBase.lst_data[a:]

#     def insert(self, data):
#         for record in data:
#             DataBase.lst_data.append(
#                 dict(zip(DataBase.FIELDS, record.split())))

# db = DataBase()
# db.insert(lst_in)
# # print(db.select(2, 4))
